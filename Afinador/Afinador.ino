//// ****** THIS FILE IS AUTOGENERATED ******
////
////          >>>> DO NOT CHANGE <<<<
////
/// 
///  Filename; C:\Users\Axel Lacapmesure\Google Drive\Facultad\2018_InstrumentacionYControl\afinador\prueba.py
///  Source class: Afinador
///  Generation timestamp: 2018-12-10T14:32:45.183219
///  Class code hash: ec302a08132b5334c2a7560439272e8414e17563
///
/////////////////////////////////////////////////////////////

#define SERIALCOMMAND_DEBUG


// Import libraries
#include <Arduino.h>
#include "SerialCommand.h"


// Definiciones propias (user):

#define BAUD_RATE 115200
#define LENGTH 200
#define FREQ 38461

bool tuned = false;
int len = LENGTH;
float reference = 440.0;
float tolerance = 20.0;
float difference = 0.0;

float compute_mean(
                   int* input,
                   int len
                   )
{
  float mean;        // Computed mean value to be returned
  int i;           // Loop counter
  
  // Loop to compute mean
  mean = 0.0;
  for (i=0; i<len; i++)
    mean += ((float)input[i]) / len;

  return(mean);
};


int detect_frequency(
                     int* input,
                     float threshold_ratio,
                     float* corr,
                     int len
                     )
{
    bool stop_condition = false;
    int max_idx = 0;
    float Norm= compute_mean(input, len)/32786;

    // Iteración para distintos lags
    for(int lag=0; lag < len; lag++)
    {
        // Computa correlación para el lag actual
        for (int i=0; i<(len-lag); i++)
            corr[lag] += (((float)input[i]/32768 - Norm) * ((float)input[i+lag]/32736 - Norm));
        corr[lag] = corr[lag] / (len - lag);

        // Detecta si el lag anterior es un pico
        if (lag > 10) {
            if (corr[lag-1]-corr[lag-2] > 0 && corr[lag-1]-corr[lag] > 0)
            {
                // Se fija si el valor de pico es mayor a threshold_ratio * corr[0]
                if (corr[lag-1] > threshold_ratio * corr[0]) {
                    max_idx = lag-1;
                    stop_condition = true;
                }
            }
        }

        if (stop_condition) break;
    };

    return max_idx;
};


// COMMAND: TUN, FEAT: tuned
int get_TUN() {
  return tuned;
};

int set_TUN(int value) {
  tuned = value;
  return 0;
};


// COMMAND: REF, FEAT: reference
float get_REF() {
  return reference;
};

int set_REF(float value) {
  reference = value;
  return 0;
};


// COMMAND: LEN, FEAT: lenght
int get_LEN() {
  return len;
};

int set_LEN(int value) {
  return 0;
};


// COMMAND: TOL, FEAT: tolerance
float get_TOL() {
  return tolerance;
};

int set_TOL(float value) {
  tolerance = value;
  return 0;
};


// COMMAND: DIFF, FEAT: difference
float get_DIFF() {
  return difference;
};

int set_DIFF(float value) {
  return 0;
};




// Definiciones SerialCommand (bridge):

const char COMPILE_DATE_TIME[] = __DATE__ " " __TIME__;

SerialCommand sCmd;

void ok() {
  Serial.println("OK");
}

void error(const char* msg) {
  Serial.print("ERROR: ");
  Serial.println(msg);
}

void error_i(int errno) {
  Serial.print("ERROR: ");
  Serial.println(errno);
}


//// Code 

void getInfo() {
  Serial.print("Afinador,");
  Serial.println(COMPILE_DATE_TIME);
}

void unrecognized(const char *command) {
  error("Unknown command");
}
//// Auto generated Feat and DictFeat Code
// COMMAND: TUN, FEAT: tuned

void wrapperGet_TUN() { 
  Serial.println(get_TUN()); 
}; 


void wrapperSet_TUN() {
  char *arg;
  
  arg = sCmd.next();
  if (arg == NULL) {
    error("No value stated");
    return;
  }
  int value = atoi(arg);

  int err = set_TUN(value);
  if (err == 0) {
    ok();
  } else {
    error_i(err);
  }
};



// COMMAND: REF, FEAT: reference

void wrapperGet_REF() { 
  Serial.println(get_REF()); 
}; 


void wrapperSet_REF() {
  char *arg;
  
  arg = sCmd.next();
  if (arg == NULL) {
    error("No value stated");
    return;
  }
  float value = atof(arg);

  int err = set_REF(value);
  if (err == 0) {
    ok();
  } else {
    error_i(err);
  }
};



// COMMAND: LEN, FEAT: lenght

void wrapperGet_LEN() { 
  Serial.println(get_LEN()); 
}; 


void wrapperSet_LEN() {
  char *arg;
  
  arg = sCmd.next();
  if (arg == NULL) {
    error("No value stated");
    return;
  }
  int value = atoi(arg);

  int err = set_LEN(value);
  if (err == 0) {
    ok();
  } else {
    error_i(err);
  }
};



// COMMAND: TOL, FEAT: tolerance

void wrapperGet_TOL() { 
  Serial.println(get_TOL()); 
}; 


void wrapperSet_TOL() {
  char *arg;
  
  arg = sCmd.next();
  if (arg == NULL) {
    error("No value stated");
    return;
  }
  float value = atof(arg);

  int err = set_TOL(value);
  if (err == 0) {
    ok();
  } else {
    error_i(err);
  }
};



// COMMAND: DIFF, FEAT: difference

void wrapperGet_DIFF() { 
  Serial.println(get_DIFF()); 
}; 


void wrapperSet_DIFF() {
  char *arg;
  
  arg = sCmd.next();
  if (arg == NULL) {
    error("No value stated");
    return;
  }
  float value = atof(arg);

  int err = set_DIFF(value);
  if (err == 0) {
    ok();
  } else {
    error_i(err);
  }
};



void setup() {
  // Bridge setup:

  //// Setup callbacks for SerialCommand commands

  // All commands might return
  //    ERROR: <error message>

  // All set commands return 
  //    OK 
  // if the operation is successfull

  // All parameters are ascii encoded strings
  sCmd.addCommand("INFO?", getInfo); 

  sCmd.setDefaultHandler(unrecognized); 


  // tuned
  // <B> bool as string: True as "1", False as "0" 

  // Getter:
  //   TUN? 
  // Returns: <B> 
  sCmd.addCommand("TUN?", wrapperGet_TUN); 

  // Setter:
  //   TUN <B> 
  // Returns: OK or ERROR    
  sCmd.addCommand("TUN", wrapperSet_TUN); 

  // reference
  // <F> float as string 

  // Getter:
  //   REF? 
  // Returns: <F> 
  sCmd.addCommand("REF?", wrapperGet_REF); 

  // Setter:
  //   REF <F> 
  // Returns: OK or ERROR    
  sCmd.addCommand("REF", wrapperSet_REF); 

  // lenght
  // <I> int as string 

  // Getter:
  //   LEN? 
  // Returns: <I> 
  sCmd.addCommand("LEN?", wrapperGet_LEN); 

  // Setter:
  //   LEN <I> 
  // Returns: OK or ERROR    
  sCmd.addCommand("LEN", wrapperSet_LEN); 

  // tolerance
  // <F> float as string 

  // Getter:
  //   TOL? 
  // Returns: <F> 
  sCmd.addCommand("TOL?", wrapperGet_TOL); 

  // Setter:
  //   TOL <F> 
  // Returns: OK or ERROR    
  sCmd.addCommand("TOL", wrapperSet_TOL); 

  // difference
  // <F> float as string 

  // Getter:
  //   DIFF? 
  // Returns: <F> 
  sCmd.addCommand("DIFF?", wrapperGet_DIFF); 

  // Setter:
  //   DIFF <F> 
  // Returns: OK or ERROR    
  sCmd.addCommand("DIFF", wrapperSet_DIFF); 


  
  // User setup:

  analogRead(A0);
  
  TIMSK0 = 0; // turn off timer0 for lower jitter
  ADCSRA = 0xe5; // set the adc to free running mode
  ADMUX = 0x40; // use adc0
  DIDR0 = 0x01; // turn off the digital input for adc0


  Serial.begin(BAUD_RATE);
  Serial.println("READY");
  Serial.flush();
}

void loop() {

  int raw_data[LENGTH];
  float autocorr[LENGTH];
  int max_idx;


  // Bridge loop:
  
  while (Serial.available() > 0) {
    sCmd.readSerial();
  }

//    // Veo si puedo leer puerto serie:
//    Serial.println("Espera...");
//    Serial.flush();
//    
//    while (!Serial.available()) {}
//
//    while(Serial.available())
//    {
//     Serial.println(Serial.read());   // this will echo your entry - read the serial buffer, format is immaterial , just looking for response    
//    }
//    Serial.flush();


  
  // User loop:

  unsigned long start_time = millis();
  
  noInterrupts();
  for (int i = 0 ; i < len ; i++) { // save 256 samples
    while(!(ADCSRA & 0x10)); // wait for adc to be ready
    ADCSRA = 0xf5; // restart adc
    byte m = ADCL; // fetch adc data
    byte j = ADCH;
    int k = (j << 8) | m; // form into an int
    k -= 0x0200; // form into a signed int
    k <<= 6; // form into a 16b signed int
    raw_data[i] = k; // put real data into bins
  }
  interrupts();

  max_idx = detect_frequency(raw_data, 0.8, autocorr, len);
  difference = FREQ/max_idx - reference;
  
  if (abs(difference) > tolerance)
    tuned = 0;
  else
    tuned = 1;

  unsigned long end_time = millis();


}
