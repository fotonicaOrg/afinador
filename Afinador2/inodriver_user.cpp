//// ****** THIS FILE IS AUTOGENERATED ******
////
////          >>>> PLEASE ADAPT IT TO YOUR NEEDS <<<<
////
/// 
///  Filename; C:\Users\Axel Lacapmesure\Google Drive\Facultad\2018_InstrumentacionYControl\afinador\prueba.py
///  Source class: Afinador2
///  Generation timestamp: 2018-12-10T15:34:52.194150
///  Class code hash: d8b86d2c295de2e888b64d479673cf2192e638e3
///
/////////////////////////////////////////////////////////////

#include "Arduino.h"
#include "inodriver_user.h"

float autocorr[LENGTH];
int max_idx;
int rawData[LENGTH];

bool tuned = false;
int len = LENGTH;
float reference = 440.0;
float tolerance = 20.0;
float difference = 0.0;

float compute_mean(
                   int* input,
                   int len
                   )
{
    float mean;        // Computed mean value to be returned
    int i;           // Loop counter
    
    // Loop to compute mean
    mean = 0.0;
    for (i=0; i<len; i++)
        mean += ((float)input[i]) / len;
  
    return(mean);
};

int detect_frequency(
                     int* input,
                     float threshold_ratio,
                     float* corr,
                     int len
                     )
{
    bool stop_condition = false;
    int max_idx = 0;
    float Norm= compute_mean(input, len)/32786;

    // Iteración para distintos lags
    for(int lag=0; lag < len; lag++)
    {
        // Computa correlación para el lag actual
        for (int i=0; i<(len-lag); i++)
            corr[lag] += (((float)input[i]/32768 - Norm) * ((float)input[i+lag]/32736 - Norm));
        corr[lag] = corr[lag] / (len - lag);

        // Detecta si el lag anterior es un pico
        if (lag > 10) {
            if (corr[lag-1]-corr[lag-2] > 0 && corr[lag-1]-corr[lag] > 0)
            {
                // Se fija si el valor de pico es mayor a threshold_ratio * corr[0]
                if (corr[lag-1] > threshold_ratio * corr[0]) {
                    max_idx = lag-1;
                    stop_condition = true;
                }
            }
        }

        if (stop_condition) break;
    };

    return max_idx;
};






void user_setup() {
}

void user_loop() {

  cli();  // UDRE interrupt slows this way down on arduino1.0
  for (int i = 0 ; i < LENGTH ; i++) { // save 256 samples
    while(!(ADCSRA & 0x10)); // wait for adc to be ready
    ADCSRA = 0xf5; // restart adc
    byte m = ADCL; // fetch adc data
    byte j = ADCH;
    int k = (j << 8) | m; // form into an int
    k -= 0x0200; // form into a signed int
    k <<= 6; // form into a 16b signed int
    rawData[i] = k; // put real data into bins
  }

  max_idx = detect_frequency(rawData, 0.98, autocorr, LENGTH);
  difference = FREQ/max_idx - reference;
  
  if (abs(difference/reference) > tolerance)
    tuned = true;
  else
    tuned = false;

  Serial.println(FREQ/max_idx);
  
}

// COMMAND: TUN, FEAT: tuned
int get_TUN() {
  Serial.println(tuned);
  return tuned;
};

int set_TUN(int value) {
  tuned = value;
  return 0;
};


// COMMAND: REF, FEAT: reference
float get_REF() {
  Serial.println(reference);
  return reference;
};

int set_REF(float value) {
  reference = value;
  return 0;
};


// COMMAND: LEN, FEAT: lenght
int get_LEN() {
  Serial.println(len);
  return len;
};

int set_LEN(int value) {
  return 0;
};


// COMMAND: TOL, FEAT: tolerance
float get_TOL() {
  Serial.println(tolerance);
  return tolerance;
};

int set_TOL(float value) {
  tolerance = value;
  return 0;
};


// COMMAND: DIFF, FEAT: difference
float get_DIFF() {
  Serial.println(difference);
  return difference;
};

int set_DIFF(float value) {
  return 0;
};
